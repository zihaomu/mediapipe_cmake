// The code of this file is modified from:
// https://github.com/google/mediapipe/blob/v0.10.9/mediapipe/tasks/cc/vision/face_landmarker/face_landmarker.cc
/* Copyright 2023 The MediaPipe Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include "face_landmark.h"
#include "face_landmark_impl.h"

using namespace cv;
namespace mpp
{
FaceLandmarker::FaceLandmarker(std::string detector_path, std::string landmark_path, int _maxFaceNum, int _device)
: maxFaceNum(_maxFaceNum), device(_device)
{
    // create faceLandmark
    faceLanmark_impl = makePtr<FaceLandmarker_Impl>(landmark_path);

    // create face detector
    faceDetector = makePtr<FaceDetector>(detector_path, maxFaceNum, device);
    smoother = makePtr<OneEuroSmoother>(0.05f, 30.f); // TODO: fine tune this params.
}

FaceLandmarker::FaceLandmarker(int _maxFaceNum, int _device)
        : maxFaceNum(_maxFaceNum), device(_device)
{
    smoother = makePtr<OneEuroSmoother>(0.05f, 30.f); // TODO: fine tune this params.
}

void FaceLandmarker::loadDetectModel(std::string detector_path)
{
    faceDetector = makePtr<FaceDetector>(detector_path, maxFaceNum, device);
}

void FaceLandmarker::loadLandmarkModel(std::string landmark_path)
{
    faceLanmark_impl = makePtr<FaceLandmarker_Impl>(landmark_path, device);
}

void FaceLandmarker::loadDetectModel(const char *buffer, long buffer_size)
{
    faceDetector = makePtr<FaceDetector>(buffer, buffer_size, maxFaceNum, device);
}

void FaceLandmarker::loadLandmarkModel(const char *buffer, long buffer_size)
{
    faceLanmark_impl = makePtr<FaceLandmarker_Impl>(buffer, buffer_size, device);
}

FaceLandmarker::~FaceLandmarker()
{

}

static BoxKp2 scaleBox(const BoxKp2& rect, float scaleFactor)
{
    BoxKp2 out = rect;
    float extendFactor = (scaleFactor - 1.0) * 0.5;

    auto& rectScaled = out.rect;
    rectScaled.x = rectScaled.x - rectScaled.width * extendFactor;
    rectScaled.y = rectScaled.y - rectScaled.height * extendFactor;

    rectScaled.width = rectScaled.width * scaleFactor;
    rectScaled.height = rectScaled.height * scaleFactor;

    return out;
}

// compute the rotation angle from the face detection keypoints.
static inline float computeRotateFromDetect(const BoxKp2& box)
{
    CV_Assert(box.points.size() == 6 && "The key points from face detector miss match the shape.");
    float x0 = box.points[0].x;
    float y0 = box.points[0].y;
    float x1 = box.points[1].x;
    float y1 = box.points[1].y;

    double r = -std::atan2(-(y1 - y0), x1 - x0);   // compute the radians
    return normalizeRadius(r);
}

static inline float computeRotateFromLandmark(const PointList3f& landmarks, int imgW, int imgH)
{
    // the 263 and 33 is the index of right eye and left eye center.
    float re_x = imgW * landmarks[263].x, re_y = imgH * landmarks[263].y;
    float le_x = imgW * landmarks[33].x, le_y = imgH * landmarks[33].y;

    double r = std::atan2(re_y - le_y, re_x - le_x);
    return normalizeRadius(r);
}

void FaceLandmarker::runDetect(const cv::Mat &img, std::vector<BoxKp2> &boxes, std::vector<float> &angles)
{
    faceDetector->run(img, boxes);

    // compute rotation angle based on the six landmark generated by face detector.
    int faceNum = boxes.size();
    angles.resize(faceNum);

    for (int i = 0; i < faceNum; i++)
    {
        angles[i] = computeRotateFromDetect(boxes[i]);
    }
}

void FaceLandmarker::runImage(const cv::Mat &img, std::vector<BoxKp3> &boxLandmark)
{
    CV_Assert(faceDetector && faceLanmark_impl && "The faceDetector or faceLanmark is null!");
    boxLandmark.clear();

    // step1: do face detect, get face and box rotation angle.
    std::vector<BoxKp2> boxes;
    std::vector<float> angles;

    this->runDetect(img, boxes, angles);
    int faceNum = boxes.size();

    for (int i = 0; i < faceNum; i++)
    {
        Mat imgCrop;
        Mat tranMatInv;

        BoxKp2 bigBox = scaleBox(boxes[i], detectBoxExpandRation);
        int H, W;
        faceLanmark_impl->getInputWH(W, H);
        imageAlignment(img, W, H, bigBox, angles[i], tranMatInv, imgCrop);

        PointList3f landmark, landmarkProjected;
        float score;

        faceLanmark_impl->run(imgCrop, landmark, score);

        if (score < threshold)
            continue;

        // project landmark back to original image.
        float ratio_z = bigBox.rect.width / (float)W / float(img.cols);
        projectLandmarkBack(landmark, img.cols, img.rows, tranMatInv, landmarkProjected, ratio_z);

        BoxKp3 boxKp3;
        boxKp3.rect = boxes[i].rect;
        boxKp3.score = boxes[i].score;
        boxKp3.points = landmarkProjected;

        boxLandmark.push_back(boxKp3);
    }
}

void FaceLandmarker::runVideo(const cv::Mat &img, std::vector<BoxKp3> &boxLandmark)
{
    CV_Assert(faceDetector && faceLanmark_impl && "The faceDetector or faceLanmark is null!");
    boxLandmark.clear();
    TickMeter t;

    // step1: do face detect, get face and box rotation angle.
    std::vector<BoxKp2> boxes;
    std::vector<float> angles;

    this->runTrack(img, boxes, angles);
    int faceNum = boxes.size();

    for (int i = 0; i < faceNum; i++)
    {
        Mat imgCrop;
        Mat tranMatInv;

        BoxKp2 bigBox = scaleBox(boxes[i], detectBoxExpandRation);
        int H, W;
        faceLanmark_impl->getInputWH(W, H);
        imageAlignment(img, W, H, bigBox, angles[i], tranMatInv, imgCrop);

        PointList3f landmark, landmarkProjected;
        float score;

        t.start();
        faceLanmark_impl->run(imgCrop, landmark, score);
        t.stop();

        if (score < threshold)
            continue;

        // project landmark back to original image.
        float ratio_z = bigBox.rect.width / (float)W / float(img.cols);
        projectLandmarkBack(landmark, img.cols, img.rows, tranMatInv, landmarkProjected, ratio_z);

        BoxKp3 boxKp3;
        boxKp3.rect = boxes[i].rect;
        boxKp3.score = boxes[i].score;
        boxKp3.points = landmarkProjected;

        boxLandmark.push_back(boxKp3);
    }

    // store the current face landmark
    if (!boxLandmark.empty())
    {
        if (boxLandmark.size() == 1)
        {
            PointList3f landmarkSmoothed;
            int64_t timestamp = std::chrono::duration_cast<std::chrono::microseconds>(
                    std::chrono::high_resolution_clock::now().time_since_epoch())
                    .count();

            smoother->apply(boxLandmark[0].points, timestamp, landmarkSmoothed);

            boxLandmark[0].points = landmarkSmoothed;
        }

        preBoxPoints = boxLandmark;
    }
    else
    {
        smoother->reset();
        preBoxPoints.clear();
    }
    // std::cout<<"time = "<<t.getTimeMilli()<<std::endl;
}

inline void getRectFromFaceLandmark(const BoxKp3& points, int imgW, int imgH, Rect2f& rect)
{
    // Find boundaries of landmarks.
    float max_x = std::numeric_limits<float>::min();
    float max_y = std::numeric_limits<float>::min();
    float min_x = std::numeric_limits<float>::max();
    float min_y = std::numeric_limits<float>::max();

    auto& pointList = points.points;
    int pointsSize = pointList.size();

    for (int i = 0; i < pointsSize; ++i)
    {
        max_x = std::max(max_x, pointList[i].x);
        max_y = std::max(max_y, pointList[i].y);
        min_x = std::min(min_x, pointList[i].x);
        min_y = std::min(min_y, pointList[i].y);
    }

    const float center_x = (max_x + min_x) * imgW / 2.f;
    const float center_y = (max_y + min_y) * imgH / 2.f;

    // bounding box
    float width = (max_x - min_x) * imgW;
    float height = (max_y - min_y) * imgH;

    // TO FINE TUNing the following params.
    float expandRatio =1.10f;
    float longEdge = std::max(width, height) * expandRatio;

    rect.width = longEdge;
    rect.height = longEdge;

    rect.x = center_x - 0.5f * longEdge;
    rect.y = center_y - 0.5f * longEdge;
}

void FaceLandmarker::runTrack(const cv::Mat &img, std::vector<BoxKp2> &boxes, std::vector<float> &angles)
{
    if (preBoxPoints.size() >= maxFaceNum) // get bounding box from pre landmark.
    {
        int preFaceNum = preBoxPoints.size();
        boxes.resize(preFaceNum);
        angles.resize(preFaceNum);

        for (int i = 0; i < preFaceNum; i++)
        {
            BoxKp2 box = {};
            Rect2f rect = {};

            float angle = computeRotateFromLandmark(preBoxPoints[i].points, img.cols, img.rows);
            getRectFromFaceLandmark(preBoxPoints[i], img.cols, img.rows, rect);
            boxes[i].rect = rect;
            angles[i] = angle;
        }
    }
    else
    {
        runDetect(img, boxes, angles);
    }
}

}
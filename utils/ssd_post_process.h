// The code of this file is modified from:
// https://github.com/google/mediapipe/blob/v0.10.9/mediapipe/calculators/tensor/tensors_to_detections_calculator.cc

// The following is original lincense:
// Copyright 2019 The MediaPipe Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef MPP_REPRODUCE_SSD_POST_PROCESS_H
#define MPP_REPRODUCE_SSD_POST_PROCESS_H

#include "common.h"
#include "ssd_anchors.h"

namespace mpp
{

struct SSDDecoderOption
{
    SSDDecoderOption(int num_classes, int num_boxes, int num_coords);
    int num_classes;
    int num_boxes;
    int num_coords;
    int keypoint_coord_offset = 0;
    float score_clipping_thresh = 0.0f;
    float min_score_thresh = 0.0f;

    enum BoxFormat
    {
        UNSPECIFIED = 0,
        YXHW = 1,
        XYWH = 2,
        XYXY = 3,

    };

    enum TensorMapping {
        detections_tensor_index = 1,
        classes_tensor_index = 2,
        scores_tensor_index = 3,
        num_detections_tensor_index = 4,
        anchors_tensor_index = 5,
    };

    // The custom model output tensor mapping.
    TensorMapping tensor_mapping; //

    int num_keypoints = 0;
    int num_values_per_keypoint = 2;
    int box_coord_offset = 0;
    float x_scale = 0.0f;
    float y_scale = 0.0f;
    float w_scale = 0.0f;
    float h_scale = 0.0f;
    bool apply_exponential_on_box_size = false;
    bool reverse_output_order = false;
    std::vector<int> ignore_classes;
    std::vector<int> allow_classes;
    bool sigmoid_score = false;

    bool flip_vertically = false;

    // The maximum number of the detection results to return.
    // If < 0, all available result will be returned.
    int max_results = -1;
    BoxFormat box_format = UNSPECIFIED;
};

// TensorsToDetectionsCalculator
// to decode the output of ssd network.
// One SSD mode has one anchor list which were generated by the SSDAnchorOptions.
class SSDDecoder
{
public:
    // Create SSD Decoder with given SSDAnchorOptions.
    SSDDecoder(const mpp::SSDAnchorOptions &anchorOptions, const SSDDecoderOption& detectorOption);
    ~SSDDecoder();

    /// Anchor decoding the Box from model output.
    /// \param boxTensor model Box and KeyPoint tensor.
    /// \param scoreTensor model score tensor.
    /// \param outBox decoded output Box,
    void run(const cv::Mat& boxTensor, const cv::Mat& scoreTensor, std::vector<BoxKp2>& outBox);

private:
    SSDDecoderOption detectorOption;
    std::vector<Anchor> anchorList;

    int num_classes;
    int num_boxes;
    int num_coords;
    SSDDecoderOption::BoxFormat box_format;
};

} // namespace mpp


#endif //MPP_REPRODUCE_SSD_POST_PROCESS_H
